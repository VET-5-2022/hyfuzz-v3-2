#!/usr/bin/env python3
"""
Professional Vulnerability Testing Framework for FTP and HTTP Servers
Uses industry-standard boofuzz framework for comprehensive security testing.

This script performs 1000 iterations of vulnerability testing and generates
detailed reports including:
- Total CVEs discovered
- Crash count and unique crashes
- Time to First Crash (TTFC)
- Time to First CVE
- Execution rate and performance metrics
- Detailed CVE breakdown by severity
"""
import argparse
import sys
import json
import time
import threading
import logging
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, field, asdict

# Rich for beautiful terminal output
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TaskID
from rich import box
from rich.live import Live
from rich.layout import Layout


@dataclass
class VulnerabilityTestResults:
    """Results from vulnerability testing."""
    target_name: str  # "FTP" or "HTTP"
    start_time: str = ""
    end_time: str = ""
    duration_seconds: float = 0.0

    # Test execution metrics
    total_iterations: int = 0
    successful_tests: int = 0
    failed_tests: int = 0

    # Vulnerability discovery
    total_cve_triggers: int = 0
    unique_cves_found: int = 0
    cve_breakdown: Dict[str, int] = field(default_factory=dict)
    cve_severity: Dict[str, str] = field(default_factory=dict)
    cve_first_trigger_time: Dict[str, float] = field(default_factory=dict)

    # Crash metrics
    total_crashes: int = 0
    unique_crashes: int = 0
    crash_hashes: set = field(default_factory=set)

    # Timing metrics
    time_to_first_crash: Optional[float] = None
    time_to_first_cve: Optional[float] = None

    # Performance metrics
    requests_per_second: float = 0.0
    avg_response_time_ms: float = 0.0

    # Error tracking
    timeout_count: int = 0
    connection_errors: int = 0
    other_errors: int = 0

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON export."""
        return {
            "target_name": self.target_name,
            "start_time": self.start_time,
            "end_time": self.end_time,
            "duration_seconds": self.duration_seconds,
            "test_execution": {
                "total_iterations": self.total_iterations,
                "successful_tests": self.successful_tests,
                "failed_tests": self.failed_tests,
            },
            "vulnerability_discovery": {
                "total_cve_triggers": self.total_cve_triggers,
                "unique_cves_found": self.unique_cves_found,
                "cve_breakdown": self.cve_breakdown,
                "cve_severity": self.cve_severity,
                "cve_first_trigger_time": self.cve_first_trigger_time,
            },
            "crash_analysis": {
                "total_crashes": self.total_crashes,
                "unique_crashes": self.unique_crashes,
            },
            "timing_metrics": {
                "time_to_first_crash": self.time_to_first_crash,
                "time_to_first_cve": self.time_to_first_cve,
            },
            "performance": {
                "requests_per_second": self.requests_per_second,
                "avg_response_time_ms": self.avg_response_time_ms,
            },
            "errors": {
                "timeout_count": self.timeout_count,
                "connection_errors": self.connection_errors,
                "other_errors": self.other_errors,
            }
        }


class VulnerabilityTester:
    """Base class for vulnerability testing."""

    def __init__(self, target_name: str, host: str, port: int):
        self.target_name = target_name
        self.host = host
        self.port = port
        self.results = VulnerabilityTestResults(target_name=target_name)
        self.start_time = None
        self.console = Console()

    def run_test(self, iterations: int = 1000) -> VulnerabilityTestResults:
        """Run vulnerability testing."""
        raise NotImplementedError

    def generate_report(self) -> str:
        """Generate test report."""
        raise NotImplementedError


class FTPVulnerabilityTester(VulnerabilityTester):
    """FTP Server Vulnerability Tester using boofuzz."""

    def __init__(self, host: str = "127.0.0.1", port: int = 2121):
        super().__init__("FTP", host, port)
        self.logger = logging.getLogger("FTP-Tester")

    def run_test(self, iterations: int = 1000) -> VulnerabilityTestResults:
        """Run FTP vulnerability tests."""
        # Import FTP-specific modules
        sys.path.insert(0, str(Path(__file__).parent / "FTP"))

        from target.vulnerable_ftp_server import VulnerableFTPServer
        from target.server_manager import ServerManager
        from fuzzer.base_fuzzer import FuzzerConfig
        from fuzzer.baseline_boofuzz import BaselineBoofuzzFuzzer
        from utils.metrics import MetricsCollector

        self.results.start_time = datetime.now().isoformat()
        self.start_time = time.time()

        self.console.print(f"[cyan]Starting FTP server on {self.host}:{self.port}...[/cyan]")

        # Start FTP server
        server = VulnerableFTPServer(
            host=self.host,
            port=self.port,
            root_dir="./ftp_test_root",
            crash_log_dir="./results/ftp_crashes"
        )

        manager = ServerManager(server, restart_delay=1.0)
        manager.start()

        if not manager.wait_for_ready(timeout=10):
            self.logger.error("FTP server failed to start")
            return self.results

        self.console.print("[green]FTP server started successfully[/green]")

        # Create metrics collector
        metrics = MetricsCollector("./results/ftp_vuln_test")

        # Create fuzzer
        config = FuzzerConfig(
            target_host=self.host,
            target_port=self.port,
            timeout=5.0,
            max_iterations=iterations
        )

        fuzzer = BaselineBoofuzzFuzzer(config, metrics)
        manager.set_fuzzer_context("vuln_test", fuzzer.session_id)

        try:
            self.console.print(f"[yellow]Running {iterations} vulnerability tests...[/yellow]")

            # Run fuzzing
            fuzzer.run(iterations)

            # Collect results
            self.results.end_time = datetime.now().isoformat()
            self.results.duration_seconds = time.time() - self.start_time

            # Get metrics
            session_metrics = metrics.get_metrics("vuln_test", fuzzer.session_id)
            if session_metrics:
                metrics.end_session("vuln_test", fuzzer.session_id)
                self._extract_metrics(session_metrics)

        except KeyboardInterrupt:
            self.console.print("[red]Test interrupted by user[/red]")
        except Exception as e:
            self.logger.error(f"Error during testing: {e}")
            self.results.other_errors += 1
        finally:
            manager.stop()

        return self.results

    def _extract_metrics(self, metrics):
        """Extract metrics from MetricsCollector."""
        self.results.total_iterations = metrics.total_iterations
        self.results.successful_tests = metrics.successful_iterations
        self.results.failed_tests = metrics.failed_iterations

        self.results.total_crashes = metrics.crashes_found
        self.results.unique_crashes = metrics.unique_crashes

        self.results.total_cve_triggers = metrics.total_cve_triggers
        self.results.unique_cves_found = len(metrics.cve_triggers)
        self.results.cve_breakdown = dict(metrics.cve_triggers)
        self.results.cve_first_trigger_time = dict(metrics.cve_first_trigger_times)

        self.results.time_to_first_crash = metrics.time_to_first_crash
        self.results.time_to_first_cve = metrics.time_to_first_cve

        self.results.requests_per_second = metrics.requests_per_second
        self.results.avg_response_time_ms = metrics.avg_response_time_ms

        self.results.timeout_count = metrics.timeout_count
        self.results.connection_errors = metrics.connection_errors
        self.results.other_errors = metrics.error_count

        # Add CVE severity information (from FTP CVE handlers)
        self._add_ftp_cve_severity()

    def _add_ftp_cve_severity(self):
        """Add severity information for FTP CVEs."""
        ftp_cve_severity = {
            "CVE-2024-46483": "CRITICAL (9.8)",
            "CVE-2024-4040": "CRITICAL (9.8)",
            "CVE-2019-12815": "CRITICAL (9.8)",
            "CVE-2010-4221": "CRITICAL (10.0)",
            "CVE-2022-34977": "CRITICAL (9.8)",
            "CVE-2017-7692": "HIGH (8.1)",
            "CVE-2024-48651": "HIGH (7.5)",
            "CVE-2023-51713": "HIGH (7.5)",
            "CVE-2015-3306": "HIGH (7.5)",
            "CVE-2019-18217": "MEDIUM (7.5)",
        }

        for cve_id in self.results.cve_breakdown.keys():
            if cve_id in ftp_cve_severity:
                self.results.cve_severity[cve_id] = ftp_cve_severity[cve_id]


class HTTPVulnerabilityTester(VulnerabilityTester):
    """HTTP Server Vulnerability Tester using boofuzz."""

    def __init__(self, host: str = "127.0.0.1", port: int = 8080):
        super().__init__("HTTP", host, port)
        self.logger = logging.getLogger("HTTP-Tester")

    def run_test(self, iterations: int = 1000) -> VulnerabilityTestResults:
        """Run HTTP vulnerability tests."""
        # Import HTTP-specific modules
        sys.path.insert(0, str(Path(__file__).parent / "HTTP"))

        from target.http_server import VulnerableHTTPServer
        from target.supervisor import ServerSupervisor
        from fuzzer.boofuzz_baseline import BoofuzzBaseline

        self.results.start_time = datetime.now().isoformat()
        self.start_time = time.time()

        self.console.print(f"[cyan]Starting HTTP server on {self.host}:{self.port}...[/cyan]")

        # Start HTTP server
        server = VulnerableHTTPServer(host=self.host, port=self.port)
        supervisor = ServerSupervisor(server)
        supervisor.start()

        time.sleep(2)  # Wait for server to be ready

        self.console.print("[green]HTTP server started successfully[/green]")

        try:
            self.console.print(f"[yellow]Running {iterations} vulnerability tests...[/yellow]")

            # Create fuzzer
            fuzzer = BoofuzzBaseline(
                target_host=self.host,
                target_port=self.port
            )

            # Track results during fuzzing
            for i in range(iterations):
                try:
                    result = fuzzer.fuzz_iteration()
                    self.results.total_iterations += 1

                    if result:
                        if result.get("success"):
                            self.results.successful_tests += 1
                        else:
                            self.results.failed_tests += 1

                        # Check for CVE triggers
                        if "cve_triggered" in result:
                            cve_id = result["cve_triggered"]
                            self.results.total_cve_triggers += 1

                            if cve_id not in self.results.cve_breakdown:
                                self.results.cve_breakdown[cve_id] = 0
                                self.results.unique_cves_found += 1

                                # Record first trigger time
                                elapsed = time.time() - self.start_time
                                self.results.cve_first_trigger_time[cve_id] = elapsed

                                if self.results.time_to_first_cve is None:
                                    self.results.time_to_first_cve = elapsed

                            self.results.cve_breakdown[cve_id] += 1

                        # Check for crashes
                        if result.get("crashed"):
                            self.results.total_crashes += 1
                            if self.results.time_to_first_crash is None:
                                self.results.time_to_first_crash = time.time() - self.start_time

                        # Track response time
                        if "response_time" in result:
                            rt = result["response_time"]
                            # Update average
                            total = self.results.avg_response_time_ms * (self.results.total_iterations - 1)
                            self.results.avg_response_time_ms = (total + rt) / self.results.total_iterations

                except TimeoutError:
                    self.results.timeout_count += 1
                    self.results.failed_tests += 1
                except ConnectionError:
                    self.results.connection_errors += 1
                    self.results.failed_tests += 1
                except Exception as e:
                    self.logger.debug(f"Error in iteration {i}: {e}")
                    self.results.other_errors += 1
                    self.results.failed_tests += 1

                # Progress indicator
                if (i + 1) % 100 == 0:
                    self.console.print(f"[dim]Progress: {i+1}/{iterations} tests completed[/dim]")

            # Calculate final metrics
            self.results.end_time = datetime.now().isoformat()
            self.results.duration_seconds = time.time() - self.start_time
            self.results.requests_per_second = self.results.total_iterations / max(self.results.duration_seconds, 1)

            # Add HTTP CVE severity
            self._add_http_cve_severity()

        except KeyboardInterrupt:
            self.console.print("[red]Test interrupted by user[/red]")
        except Exception as e:
            self.logger.error(f"Error during testing: {e}")
            self.results.other_errors += 1
        finally:
            supervisor.stop()

        return self.results

    def _add_http_cve_severity(self):
        """Add severity information for HTTP CVEs."""
        http_cve_severity = {
            "CVE-2024-27316": "HIGH (7.5)",
            "CVE-2024-24795": "MEDIUM (6.1)",
            "CVE-2024-38476": "MEDIUM (6.5)",
            "CVE-2024-38477": "HIGH (7.5)",
            "CVE-2024-4577": "CRITICAL (9.8)",
            "CVE-2024-23897": "CRITICAL (9.8)",
            "CVE-2024-50379": "HIGH (7.0)",
            "CVE-2024-21733": "MEDIUM (5.3)",
            "CVE-2024-53677": "CRITICAL (9.1)",
            "CVE-2025-24813": "CRITICAL (9.8)",
        }

        for cve_id in self.results.cve_breakdown.keys():
            if cve_id in http_cve_severity:
                self.results.cve_severity[cve_id] = http_cve_severity[cve_id]


class VulnerabilityTestRunner:
    """Main test runner for both FTP and HTTP vulnerability testing."""

    def __init__(self):
        self.console = Console()
        self.results: Dict[str, VulnerabilityTestResults] = {}

    def run_all_tests(self, iterations: int = 1000, targets: List[str] = None):
        """Run tests on all specified targets."""
        if targets is None:
            targets = ["ftp", "http"]

        self.console.print(Panel.fit(
            "[bold blue]Professional Vulnerability Testing Framework[/bold blue]\n"
            f"Framework: boofuzz (Industry Standard)\n"
            f"Iterations: {iterations} per target\n"
            f"Targets: {', '.join(targets).upper()}",
            border_style="blue"
        ))

        for target in targets:
            target_lower = target.lower()

            if target_lower == "ftp":
                tester = FTPVulnerabilityTester()
                results = tester.run_test(iterations)
                self.results["FTP"] = results

            elif target_lower == "http":
                tester = HTTPVulnerabilityTester()
                results = tester.run_test(iterations)
                self.results["HTTP"] = results

        # Display comprehensive report
        self.display_results()

    def display_results(self):
        """Display comprehensive vulnerability test results."""
        self.console.print("\n")
        self.console.print(Panel.fit(
            "[bold green]VULNERABILITY TESTING RESULTS[/bold green]",
            border_style="green"
        ))

        # Summary table
        self._display_summary_table()

        # CVE breakdown for each target
        for target_name, results in self.results.items():
            if results.unique_cves_found > 0:
                self._display_cve_breakdown(target_name, results)

        # Timing metrics
        self._display_timing_metrics()

        # Save detailed report
        self.save_report()

    def _display_summary_table(self):
        """Display summary results table."""
        table = Table(
            title="Overall Test Summary",
            box=box.ROUNDED,
            show_header=True,
            header_style="bold magenta"
        )

        table.add_column("Target", style="cyan", width=12)
        table.add_column("Iterations", justify="right", style="green")
        table.add_column("CVEs Found", justify="right", style="yellow")
        table.add_column("Total Triggers", justify="right", style="yellow")
        table.add_column("Crashes", justify="right", style="red")
        table.add_column("TTFC (s)", justify="right", style="blue")
        table.add_column("Rate (req/s)", justify="right", style="blue")
        table.add_column("Errors", justify="right", style="dim")

        for target_name, results in self.results.items():
            ttfc = f"{results.time_to_first_crash:.2f}" if results.time_to_first_crash else "N/A"

            table.add_row(
                target_name,
                str(results.total_iterations),
                str(results.unique_cves_found),
                str(results.total_cve_triggers),
                str(results.total_crashes),
                ttfc,
                f"{results.requests_per_second:.2f}",
                str(results.timeout_count + results.connection_errors + results.other_errors)
            )

        self.console.print(table)
        self.console.print()

    def _display_cve_breakdown(self, target_name: str, results: VulnerabilityTestResults):
        """Display CVE breakdown for a target."""
        table = Table(
            title=f"{target_name} CVE Breakdown",
            box=box.ROUNDED,
            show_header=True,
            header_style="bold cyan"
        )

        table.add_column("CVE ID", style="yellow", width=20)
        table.add_column("Severity", style="red", width=18)
        table.add_column("Triggers", justify="right", style="green")
        table.add_column("First Trigger (s)", justify="right", style="blue")

        # Sort CVEs by trigger count
        sorted_cves = sorted(
            results.cve_breakdown.items(),
            key=lambda x: x[1],
            reverse=True
        )

        for cve_id, count in sorted_cves:
            severity = results.cve_severity.get(cve_id, "UNKNOWN")
            first_trigger = results.cve_first_trigger_time.get(cve_id, 0)

            table.add_row(
                cve_id,
                severity,
                str(count),
                f"{first_trigger:.2f}"
            )

        # Add total row
        table.add_row(
            "[bold]TOTAL[/bold]",
            "",
            f"[bold]{results.total_cve_triggers}[/bold]",
            ""
        )

        self.console.print(table)
        self.console.print()

    def _display_timing_metrics(self):
        """Display timing and performance metrics."""
        table = Table(
            title="Timing & Performance Metrics",
            box=box.ROUNDED,
            show_header=True,
            header_style="bold green"
        )

        table.add_column("Target", style="cyan", width=12)
        table.add_column("Duration (s)", justify="right")
        table.add_column("TTFC (s)", justify="right")
        table.add_column("TTFCVE (s)", justify="right")
        table.add_column("Avg Response (ms)", justify="right")
        table.add_column("Throughput (req/s)", justify="right")

        for target_name, results in self.results.items():
            ttfc = f"{results.time_to_first_crash:.2f}" if results.time_to_first_crash else "N/A"
            ttfcve = f"{results.time_to_first_cve:.2f}" if results.time_to_first_cve else "N/A"

            table.add_row(
                target_name,
                f"{results.duration_seconds:.2f}",
                ttfc,
                ttfcve,
                f"{results.avg_response_time_ms:.2f}",
                f"{results.requests_per_second:.2f}"
            )

        self.console.print(table)
        self.console.print()

    def save_report(self):
        """Save detailed test report to JSON."""
        results_dir = Path("./results/vulnerability_testing")
        results_dir.mkdir(parents=True, exist_ok=True)

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

        # Save individual target results
        for target_name, results in self.results.items():
            filename = results_dir / f"{target_name.lower()}_vuln_test_{timestamp}.json"
            with open(filename, 'w') as f:
                json.dump(results.to_dict(), f, indent=2)
            self.console.print(f"[green]✓[/green] {target_name} results saved to: {filename}")

        # Save combined report
        combined_report = {
            "test_timestamp": timestamp,
            "test_date": datetime.now().isoformat(),
            "framework": "boofuzz (Industry Standard)",
            "targets_tested": list(self.results.keys()),
            "results": {
                target: results.to_dict()
                for target, results in self.results.items()
            },
            "summary": {
                "total_iterations": sum(r.total_iterations for r in self.results.values()),
                "total_unique_cves": sum(r.unique_cves_found for r in self.results.values()),
                "total_cve_triggers": sum(r.total_cve_triggers for r in self.results.values()),
                "total_crashes": sum(r.total_crashes for r in self.results.values()),
            }
        }

        combined_file = results_dir / f"combined_vuln_test_{timestamp}.json"
        with open(combined_file, 'w') as f:
            json.dump(combined_report, f, indent=2)

        self.console.print(f"[green]✓[/green] Combined report saved to: {combined_file}")
        self.console.print()


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Professional Vulnerability Testing Framework for FTP/HTTP Servers",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Test both FTP and HTTP servers with 1000 iterations each
  python vulnerability_testing.py --iterations 1000

  # Test only FTP server
  python vulnerability_testing.py --target ftp --iterations 1000

  # Test only HTTP server
  python vulnerability_testing.py --target http --iterations 1000

  # Verbose output
  python vulnerability_testing.py --iterations 1000 --verbose

Features:
  - Uses boofuzz (industry-standard fuzzing framework)
  - Comprehensive CVE detection (10 CVEs per target)
  - Detailed metrics: crashes, TTFC, execution rate
  - Professional reporting with Rich terminal output
  - JSON export for further analysis
        """
    )

    parser.add_argument(
        "--iterations", "-i",
        type=int,
        default=1000,
        help="Number of test iterations per target (default: 1000)"
    )

    parser.add_argument(
        "--target", "-t",
        choices=["ftp", "http", "both"],
        default="both",
        help="Target server(s) to test (default: both)"
    )

    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Enable verbose logging"
    )

    parser.add_argument(
        "--ftp-port",
        type=int,
        default=2121,
        help="FTP server port (default: 2121)"
    )

    parser.add_argument(
        "--http-port",
        type=int,
        default=8080,
        help="HTTP server port (default: 8080)"
    )

    args = parser.parse_args()

    # Setup logging
    log_level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(
        level=log_level,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )

    # Determine targets
    if args.target == "both":
        targets = ["ftp", "http"]
    else:
        targets = [args.target]

    # Run tests
    runner = VulnerabilityTestRunner()

    try:
        runner.run_all_tests(iterations=args.iterations, targets=targets)
    except KeyboardInterrupt:
        print("\n[!] Testing interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"[!] Error during testing: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
